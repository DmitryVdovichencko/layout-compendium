# Разбираемся с системой координат и трансформациями SVG. Часть 1 `viewport` , `viewBox`, `preserveAspectRatio`.
Оригинал: [Sara Soueidan "Understanding SVG Coordinate Systems and Transformations"](https://www.sarasoueidan.com/blog/svg-coordinate-systems/)

SVG элементы не регламентированы моделью CSS Box как элементы HTML. Это делает позиционирование и трансформацию этих элементов довольно непростыми и, как может показаться на первый взгляд, менее интуитивными. В любом случае, однажды разобравшись с тем, как работают система координат и трансформации SVG, манипуляции с SVG графикой станут намного легче и обретут больше смысла. В этой статье мы разберем три самых важных аттрибута SVG которые оказывают влияние на систему координат: `viewport` , `viewBox`, `preserveAspectRatio`.

Это первая часть серии из трех статей о системе координат и трансформациях в SVG.


[Разбираемся с системой координат и трансформациями SVG. Часть 1 `viewport` , `viewBox`, `preserveAspectRatio`](https://www.sarasoueidan.com/blog/svg-coordinate-systems/)

[Разбираемся с системой координат и трансформациями SVG. Часть 2 – Аттрибут `transform`](http://sarasoueidan.com/blog/svg-transformations)

[Разбираемся с системой координат и трансформациями SVG. Часть 3 – Определяем новый `viewport`](http://sarasoueidan.com/blog/nesting-svgs)
   
Для визуализации основных принципов и объяснений в статье далее, автором было создано интерактивное демо, позволящее поиграться со значениями аттрибутов `viewBox` и `preserveAspectRatio`.

[Здесь можно посмотреть интерактивное демо](https://www.sarasoueidan.com/demos/interactive-svg-coordinate-system/)

Демо это такая вишенка на торте, так что советую вернуться к чтению статьи, если вы посмотрите демо перед этим.

## Оболочка SVG

Оболочка это пространство или область, на которой отрисовано содержимое SVG. В принципе, эта оболочка бесконечна в обоих измерениях. Поэтому, SVG может быть любых размеров. Но, все же, SVG графика будет отрисована относительно определенной области известной как `viewport`. Области SVG, которые лежат за пределами `viewport` будут обрезаны и не отобразятся.

### Viewport

`Viewport` - это отображаемая область, где будет показана SVG графика. Вы можете думать о `viewport` как об окошке, через которое можно увидеть какой нибудь пейзаж. И пейзаж через это окно может быть виден полностью или частично.

`Viewport`  SVG похож на `viewport` браузера через который вы смотрите странички в интернете. Веб страница может быть любого размера; она может быть шире чем ширина `viewport` и, в большинстве случаев, длинее чем длина `viewport`. В любом случае в определенный момент через `viewport` браузера видны лишь части страницы.

Так или иначе, вся оболочка SVG будет отображена или только ее часть зависит от размера этой оболочки и значения аттрибута `preserveAspectRatio`. Не нужно сейчас об этом беспокоиться; позже мы поговорим подробнее об этом аттрибуте.

Вы определяете размер `viewport`, используя аттрибуты `width` и `height` внешнего `<svg>` элемента.

```html

<!-- viewport будет 800px на 600px -->
<svg width="800" height="600">
    <!-- содержимое SVG отрисованное внутри SVG оболочки -->
</svg>
```

В SVG, значения могут быть установлены с использованием единиц измерения или без них. Значения без единиц измерения говорят о том, что пространство будет определено с помощью пользовательских единиц измерения. Если значение, определено с пользовательскими единицами, значит предполагается что значение будет равно тому же числу в `px`. Это означает, что в примере выше `viewport` будет отрисован с размерами `800px` на `600px`.

Вы также можете определять значения с использованием единиц измерения. Поддерживаются следующие единицы измерения: `em, ex, px, pt, pc, cm, mm, in, %`

Как только будут установлены ширина и высота внешнего SVG элемента, браузер создаст исходную систему координат `viewport` и исходную систему координат пользователя.

### Исходная система координат

Исходная система координат `viewport` - это система координат созданная на `viewport` с началом в левом верхнем углу в точке `(0,0)`, позитивное направление оси X - вправо, позитивное направление оси Y - вниз, и одно деление в исходной системе координат равно одному `px` `viewport`. Эта система координат похожа на систему координат для HTML элементов в соответствие с блочной моделью CSS.

Пользовательская исходная система координат - это система координат созданная на основе оболочки SVG. Эта система координат изначально идентична системе координат `viewport` с началом в левом верхнем углу в точке `(0,0)`, позитивное направление оси X - вправо, позитивное направление оси Y - вниз. Используя аттрибут `viewBox` исходная пользовательская система координат - также известная как выбранная система координат или используемая пользовательская область - может быть изменена таким образом, что она больше не будет идентична системе координат `viewport`. Мы поговорим об этом подробнее в следующей главе. 

На данный момент мы не будем использовать аттрибут `viewBox`. Пользовательская система координат будет идентична системе координат `viewport`.

На следующем изображении, “оси” системы координат `viewport` - серые, а те оси что относятся к пользоватльской системе координат  `viewBox` - голубые. Поскольку обе системы координат на данный момент идентичны, они наложны друг на друга.

![initial-coordinate-systems](https://d33wubrfki0l68.cloudfront.net/fedcd70d34fc3a5dea2369e727b6a8e7081de43b/3496e/images/initial-coordinate-systems.jpg)

Попугай на этом SVG имеет рамку размером 200 единиц (200px в данном случае) в ширину и 300 единиц в высоту. Попугай отрисован в рамке на основе исходной системы координат

Новое пользовательское пространство (т.е. новая выбранная система координат) может быть получено с помощью определения трасформаций через аттрибут `transform` для элемента контейнера или графического элемента. Мы поговорим о трансформациях во второй части этой статьи и более детально в третьей последней части.

### `viewBox`

Мне нравится думать о `viewBox` как о __"реальной"__  системе координат. В конце концов, именно эта система координат используется для отрисовки графики SVG в оболочке. Эта система координат может быть меньше или больше чем `viewport`, и также может частично или полностью отображаться в окне просмотра.

В прошлый раз, пользовательская система координат была идентична системе координат `viewport`. Дело в том, что мы просто не определили ее по другому. Вот почему все расположение и отрисовка выполнены относительно системы координат `viewport`.
Как только мы создали систему координат `viewport` (назначив `width` и` height`) , браузер создал стандартную пользовательскую систему координат идентичную `viewport`.

Вы определяете вашу собственную пользовательскую систему координат используя аттрибут `viewBox`. Если пользовательская система координат, которую вы выбрали, имеет то же соотношение сторон (отношение высоты к ширине) как система координат `viewport`, то пользовательская система координат заполнит всю область `viewport` (поговорим о примерах через минуту). В любом случае, если ваша пользовательская система координат определена с другим соотношением сторон, вы можете использовать аттрибут `preserveAspectRatio`, чтобы определить будет ли вся графика отображаться внутри `viewport` и также вы можете использовать его для позиционирования графики внутри `viewport`. Мы рассмотрим все в деталях и примерах для таких случаев в сдедующей главе. А пока мы посмотрим на те примеры, где соотношение сторон `viewBox` совпадает с `viewport`  - в этих примерах `preserveAspectRatio` не будет оказывать никакого влияния.

Но прежде чем перейдем к примерам, посмотрим на синтаксис `viewBox`.

### Синтаксис `viewBox`

Аттрибут `viewBox` принимает четыре параметра: `<min-x>`, `<min-y>`, `width` и`height`.
```html
viewBox = <min-x> <min-y> <width> <height>
```

Значения `<min-x>` и `<min-y>` определяют левый верхний угол `viewBox`, а  `width` и `height` - ширину и высоту `viewBox`.

Заметьте, здесь ширина и высота не обязательно должны быть такими же как и в родительском `<svg>` элементе. Негативные значения ширины и высоты являются некорректными. Нулевые значения отменяют рендеринг элемента.

И также, можно заметить, что ширине `viewport` может быть назначено любое значение с помощью CSS. Например, если установить ширину 100% SVG заполнит документ. Каким бы ни было значение `viewBox`, оно будет вписано в вычисленную ширину наружного SVG.  

Так выглядит пример настройки `viewBox`:
```html
<!-- viewbox в этом примере равен viewport, но они могут быть различными -->
<svg width="800" height="600" viewbox="0 0 800 600">
    <!-- SVG содержимое отрисованное в оболочке SVG  -->
</svg>
```

Если вы читали о `viewBox` где-нибудь ранее, возможно вы  столкнулись с несколькими определениями, которые говорили о том, что вы можете использовать `viewBox` для преобразования графики SVG, масштабируя или перемещая ее. Это верно. Я собираюсь зайти дальше и сказать, что  с помощью `viewBox` вы можете даже обрезать SVG.

Лучший способ понять как работает `viewBox` и чем он отличается от `viewport` - визуализировать их. Так что давайте начнем с нескольких примеров. Сначала посмотрим примеры с одинаковым соотношением сторон `viewBox` и`viewport` , в этом случае, нам пока не нужно будет разбираться с тем, как работает `preserveAspectRatio`.

Вот простой пример. `viewBox` в этом примере будет в два раза меньше чем `viewport`. Мы не изменяли начало координат `viewBox` в данном случае, так что обе оси начинаются от нулевой точки. Ширина и высота `viewBox` будут составлять половину ширины и высоты 
`viewport`. Это означает, что мы сохранили соотношение сторон. 

```html
<svg width="800" height="600" viewbox="0 0 400 300">
    <!-- SVG содержимое отрисованное в оболочке SVG  -->
</svg>
```

Что именно делает `viewbox="0 0 400 300"`?

- [x] Определяет специальную область от левого верхнего края в точке (0, 0) до точки (400, 300)
- [x] SVG графика обрезается до этой области
- [x] Область масштабируется (увеличивается) для заполнения всего `viewport`
- [x] Пользовательская система координат приводится к системе координат `viewport` так что в данном случае одно деление пользовательской системы координат будет равно двум делениям `viewport`

Следующее изображение показывает результат применения `viewbox` к оболочке `<svg>` в нашем примере. Серые деления представляют систему координат `viewport`, голубые - пользовательскую систему координат созданную с помощью `viewbox`. Назначая `viewbox` можно получить результат похожий на обрезку графики по `viewbox` и масштабирования ее до заполнения всей области `viewport`. И помним, что мы, пока что, сохраняем то же соотношение сторон, что и у `viewport`. 

![viewbox-crop](https://d33wubrfki0l68.cloudfront.net/e6639267b77782b0d62ce5f29a4d9b07bf5df87a/14c69/images/viewbox-400-300-crop.jpg)

Все что вы можете нарисовать в оболочке SVG будет отрисовано относительно новой пользовательской системы координат.

Мне нравится представлять оболочку SVG с `viewBox` как Google Maps. Вы можете увеличить определенную область или регион в картах Google; только эта область будет отображена и увеличена до заполнеия всего `viewport` браузера. Тем не менее, вы знаете что остальная часть карты все еще здесь, просто она не отображается т.к. выходит за границы `viewport` - и значит эта оставшаяся часть будет отсечена.

Теперь давайте попробуем изменить значения `<min-x>` и `<min-y>`. Назначим обоим аттрибутам значение 100. Можно выбрать любое число, какое вы захотите. Соотношение сторон выберем таким же, как у `viewport` 

```html
<svg width="800" height="600" viewbox="100 100 200 150">
    <!-- SVG content drawn onto the SVG canvas -->
</svg>
```

Эффект применения `viewBox="100 100 200 15` такой же как и в предыдущем примере - обрезка изображения. Графика обрезана и отмасштабирована для заполнения `viewport` 

![viewbox-crop translate](https://d33wubrfki0l68.cloudfront.net/59a2fdb34e4735b8cdb865efe7233ac373b5fc43/d5d7d/images/viewbox-200-150-crop.jpg)

Еще раз, пользовательская система координат вписана в систему координат `viewport` - 200 пользовательских единиц соответствуют 800 единицам `viewport`, т.о. каждая пользовательская единица  равна 4 единицам `viewport` . В результате получается такой зум - эффект как на скриншоте выше. 

Также заметим, что в этом случае, определив ненулевые значения для `<min-x>` и `<min-y>` мы создаем эффект трансформации графики;более специфическим способом чем перенос оболочки SVG с помощью `transform="translate(-100 -100)"`  

Действительно, как говорит спецификация:

> Эффект применения `viewBox` в том, что со стороны пользователя автоматически поддерживается соответствующая матрица трансформаций чтобы вписать определенную область пользовательского пространства в границы области назначения (часто `viewport`).

Это просто более сложный способ сказать о том, что мы отмечали ранее: графика обрезается и масштабируется до заполнения `viewport`. Затем в спецификации добавлено примечание:

> В некоторых случаях на стороне пользователя необходима поддержка трансформации переноса в дополнение к масштабированию. Например, на внешнем SVG элементе, трансформация переноса понадобится если для `viewBox` определены ненулевые значения для `<min-x>` или `<min-y>`.

Чтобы лучше продемонстрировать трансформацию переноса, давайте применим отрицательное значение (-100) для `<min-x>` и `<min-y>`.
Эффект переноса будет такой же как при применении `transform="translate(100 100)"`; это означает, что графика будет перенесена вниз и вправо после обрезки и масштабирования. Так будет выглядеть код предыдущего примера с отрицательными значениями для `<min-x>` и `<min-y>`

```html
<svg width="800" height="600" viewbox="-100 -100 400 300">
    <!-- SVG content drawn onto the SVG canvas -->
</svg>
```

Результат применения примера выше будет выглядеть следующим образом:

![viewbox-crop-translate](https://d33wubrfki0l68.cloudfront.net/a31c4b3156fec4d20bc555d3ec4d9f7ca6c291fb/832dc/images/viewbox-400-300-crop-translate.jpg)

Заметим, что в отличие от применения аттрибута `transform`, автоматическая трансформация выполненная с применением `viewBox` не влияет на `x` и `y`, и ширину и высоту элемента с аттрибутом `viewBox`. Таким образом в примере выше, в котором показано что `svg` элемент имеющий аттрибуты `width`, `height` и `viewBox`, ширина и высота представлены элемента в системе координат, которая была до применения трансформации `viewBox`. Вы можете увидеть это в примерах выше, поскольку так же как и исходная ( серая ),
система координат `viewport` осталась неизменной после использования аттрибута `viewBox` на `svg`.

С другой стороны, как и свойство `transform`, это создает новую систему коррдинат для всех других аттрибутов и для элементов-потомков.
Как видно в примерах, как только пользовательская система координат создана - она уже не будет идентична системе координат `viewport`, как исходная система координат до использования `viewBox`. И все потомки `svg` будут позиционироваться и масштабироваться в новой пользовательской системе координат, а не в той, что была исходной.

Наш последний пример `viewBox` похож на предыдущий, но вместо обрезки оболочки мы собираемся расширить ее внутри `viewport` и посмотреть как это повлияет на графику. Мы определим `viewBox` с выстой и шириной больше чем у `viewport`, тем не менее соблюдая соотношение сторон `viewport`, мы разберемся с разными соотношениями сторон в следующей главе.

В этом примере, мы создадим `viewBox` в 1.5 раза превышающий `viewport`

```html
<svg width="800" height="600" viewbox="0 0 1200 900">
    <!-- SVG content drawn onto the SVG canvas -->
</svg>
```

Что случится теперь, когда пользовательская система координат должна будет масштабироваться до размеров 1200х900? Пользовательская система координат будет вписана в систему координат `viewport` таким образом, что каждая единица пользовательской системы координат будет равно отношению `vieport-width/vieBox-width` по ширине и `vieport-height/vieBox-height` по высоте в системе координат `viewport`. Это означает, что в нашем случае, каждая единица по оси `x` в пользовательской системе координат будет равна `0.66` по оси `x` `viewport` и каждая пользовательская единица по оси `y` будет равна `0.66` по оси `y` `viewport`.

Конечно, лучший способ понять все это - визуализировать результат. `viewBox` масштабируется таким образом чтобы поместиться внутри `viewport` как показано на следующем изображении. И т.к. графика отрисовывается в оболочке основаной на новой пользовательской системе координат, а не системе координат `viewport`, она выглядит меньше внутри `viewport`. Пользовательская система координат 1200x900 вписана в систему координат `viewport` 800x600. Серые деления представляют систему координат `viewport`; голубые - систему координат созданную `viewBox`.

![viewBox scaled 1.5](https://d33wubrfki0l68.cloudfront.net/423b1dae8696c091dc8f999c0f1c99a419302c48/2df7b/images/viewbox-1200-900.jpg)

До сих пор все наши примеры хорошо уживались с соотношением высоты и ширины `viewport`. Но что будет, если высота и ширина, определенные в аттрибуте `viewBox` имеют другое соотношение сторон, отличающееся от  `viewport`? Например,предположим мы выбрали `viewBox` 1000x500. Соотношение сторон теперь уже не такое как у `viewport`. Результат использования `viewBox = "0 0 1000 500"` для нашего примера будет выглядеть следующим образом:


![viebox 1000 x 500](https://d33wubrfki0l68.cloudfront.net/b78870133c46cf41fda5933597744438eaa730f7/573e9/images/viewbox-1000-500.jpg)

Пользовательская система координат, а значит и графика спозиционируются внутри `viewport` таким образом:

The user coordinate system and hence the graphic is positioned inside the viewport so that:
- [x] Весь `viewBox` помещается внутри `viewport`
- [x] В приоритете соотношение сторон `viewBox`. `viewBox` не растянется чтобы закрыть всю область `viewport`
- [x] `viewBox`будет расположен по центру `viewport`как по вертикали так и по горизонтали

Это стандартное поведение. Что может на него повлиять? И что если нам понадобится изменить позицию `viewBox` внутри `viewport`. И  тут в дело вступает аттрибут `preserveAspectRatio`

### Аттрибут `preserveAspectRatio` 

Аттрибут `preserveAspectRatio` используется для принудительного единого масштабирования чтобы сохранить предпочтительное соотношение сторон для графики. 

Если вы определили пользовательскую систему координат с соотношением сторон отличающимся от `viewport`, и если браузер растянул `viewBox` для заполнения `viewport` как мы видели в предыдущих примерах, различие в сотношениях сторон спровоцирует искажение графики в любом направлении. Так что если `viewBox` в последнем примере будет растянут для заполнения `viewport` в обоих направлениях, графика будет выглядеть как то так:

![without preserveaspectratio](https://d33wubrfki0l68.cloudfront.net/1429df6a1bd831d42096cea4cbbb409d5b848520/b53cd/images/viewbox-1000-500-stretched.jpg)

Графика выглядит так, будто ее сжали по горизонтали и растянули по вертикали.

Искажение также хорошо будет заметно (что конечно, нежелательно) при использовании `viewBox` со значением ` 0 0 200 300`,  что является меньше чем размеры `viewport`. Мы специально взяли такое значение, чтобы `viewBox` достигал размеров оболочки попугая. Если браузер растянет графику для заполнения `viewport`, это будет выглядеть так:

![without preserveaspectratio](https://d33wubrfki0l68.cloudfront.net/bf423ebd23296696fecedfbb96676d9876966963/b5842/images/viewbox-200-300-stretched.jpg)

Аттрибут `preserveAspectRatio` позволяет вам принудительно масштабировать `viewBox`, чтобы сохранить соотношение сторон, и это позволит вам определить как позиционировать `viewBox` внутри `viewport`, если вы не хотите чтобы `viewBox` был отцентрован по умолчанию.

### Синтаксис `preserveAspectRatio`

Официальный синтаксис `preserveAspectRatio`:

```html
preserveAspectRatio = defer? <align> <meetOrSlice>?
```
Это применимо для любого элемента, создающего новый `viewport` (мы разберем это в следующей части серии статей)

Аргумент `defer` - опциональный и используется только когда вы применяете `preserveAspectRatio` к `<image>`. Он игнорируется при применении на другом элементе. Т.к. применение аттрибутов к `<image>` выходит за рамки нашей статьи, мы пока пропустим аргумент `defer`.

Параметр `align` определяет нужно ли применять принудительное масштабирование, и, если да, то какое выравнивание применить в случае несовпадения соотношения сторон `viewBox` и `viewport`.

Если параметр `align` установить в `none`, например:

```html
preserveAspectRatio = "none"
```

Графика будет масштабирована до заполнения `viewport` без поддержания соотношения сторон, как мы видели в последних двух примерах.

Любые другие значения `preserveAspectRatio` включают принудительное масштабирование с поддержанием соотношения сторон `viewBox`, и определяют как выровнять `viewBox` внутри `viewport`. Мы быстренько пробежимся по этим значениям.

Последний аргумент `meetOrSlice` тоже опциональный и имеет значение по умолчанию `meet`. Аргумент определяет, должен ли весь `viewBox` отображаться внутри `viewport`. Если указываем этот аргумент нужно отделить его от аргумента `align` одним или более пробелом. Например: 

```html
preserveAspectRatio = "xMinYMin slice"
```

Все эти значения сначала выглядят незнакомыми. Чтобы было проще понять их и познакомиться с ним поближе, вы можете представлять `meetOrSlice` как похожие значения свойства `background-size` : `contain` и `cover`; они работают почти одинаково. `meet` похож на `contain`, а `slice` похож на `cover`. Вот определение и сущность этих значений:


#### `meet` (Значение по умолчанию)
  
 Масштабирует графику насколько это возможно, соблюдая два критерия:

* __Соотношение сторон в приоритете__
* __Весь `viewBox` должен быть виден внутри `viewport`__

В этом случае, если соотношение сторон графики не совпадает с соотношением сторон `viewport`, некоторая часть `viewport` будет расширена за границы `viewBox` ( т.е. область `viewBox` будет отрисована меньше чем `viewport` - как в последнем примере в главе про `viewBox`). В этом случае  границы `viewBox` будут находится внутри `viewport`, так что из рамки как бы __"встретятся" (с англ. "meet")__.

> Это значение похоже на `background-size: contain`. Когда фоновое изображение масштабирутся насколько это возможно, при этом поддерживая соотношение сторон и убедившись в том, что оно полностью поместится в предназначенную для него область. Если соотношение сторон фонового изображения не совпадает с сооотношением сторон элемента, к которому его применили, часть области этого элемента не будет  закрыта фоновым изображением.

#### `slice`

Масштабирует графику до тех пор пока `viewBox` не покроет всю область `viewport`, при этом сохраняя соотношение сторон. `viewBox` масштабируется для того чтобы закрыть `viewport` (по обоим осям), но не больше чем необходимо для этого. Другими словами, масштабируется до наименьшего размера, достаточного чтобы закрыть `viewport` по ширине и высоте.

В этом случае, если соотношение сторон `viewBox` не совпадает с соотношением сторон `viewport`, часть `viewBox`будет расширена за пределы `viewport` (т.е. область в которой будет отрисован `viewBox` станет больше чем `viewport`). Это приведет к тому, что часть `viewBox` будет __"отсечена" ( с англ. "sliced off")__.

> Можете представлять такое поведение как при использовании `background-size: cover`. В этом случае фоновое изображение будет масштабироваться с соблюдением пропорций до наименьшего размера, способного полностью закрыть область применения фона, как по ширине так и по высоте.

Так что `meetOrSlice` используются для того, чтобы определить будет ли `viewBox` полностью помещаться внутри `viewport`, или он должен быть масштабирован настолько, насколько необходимо, чтобы заполнить `viewport`, даже если часть `viewBox` будет отсечена.

Например, если мы применяем `viewBox` размерами 200x300, и попробуем оба значения свойства `meet` и `slice`, сохраняя браузерное значение по умолчанию для выравния графики, результат будет выглядеть так:

![result meet and slice](https://d33wubrfki0l68.cloudfront.net/1c0be52ee4e8411e75db7b0f967ccfa6cdb762ca/6e9ca/images/viewbox-200-300-meet-vs-slice.jpg)

Стандартное значение для выравнивания - `xMidYMid`, значит, в обоих случаях, графика будет масштабироваться так что ее центральные оси выровняются с центральными осями `viewport`.

Параметр `align` принимает одно из 9 значений или значение `none`. Любое значение отличающееся от `none` используется для универсального масштабирования графики с сохранением соотношения сторон, и также используется для выравнивания `viewBox` внутри `viewport`.

Значения параметра align работают схоже со значениями свойства `background-position`, когда его используют с процентными значениями. Вы можете думать о `viewBox` как о `background-image`. Способ позиционирования с `align` отличается от `background-position` тем, что вместо позиционирования определенных точек `viewBox` относительно соответствующих точек `viewport`, мы выравниваем оси  `viewBox` относительно соответствующих осей `viewport`.

Чтобы по порядку разобраться с каждым из значений `align`, нам сначало нужно познакомиться с каждой осью.

Помните значения `<min-x>` и `<min-y>` для `viewBox`? Мы собираемся использовать их для определения осей `viewBox` - `<min-x>` и `<min-y>`. Дополнительно мы определим две оси `max-x` и `max-y`, которые будут расположены на `<min-x> + width` и `<min-y> + height` соответственно. И последнее, но не менее важное: мы определим две оси `<mid-x>` и `<mid-y>`, которые будут расположены на `<min-x> + (width/2)` и `<min-y> + (height/2)` соответственно.

Еще не запутались? Если да то вот вам картинка где предсталены все эти оси. Здесь оба начальных значения `<min-x>` и `<min-y>` выбраны по умолчанию - 0. `viewBox` выбран `viewBox = "0 0 300 300"`. Розовые и оранжевые линии представляют собой значения `<min-x>` и `<min-y>` сответственно. Пунктирные розовые и оранжевые линии используются для средних и максимальных значений.

![viewBox axes](https://d33wubrfki0l68.cloudfront.net/1788c7fec01fa6aa391a418e3ce29ff19de533a0/11b57/images/viewbox-x-y-axes.jpg)

Серые пунктирные линии показывают средние оси `viewport`. 


Значения для выравнивания следующие:

#### `none`
   
* Не используем универсальное масштабирование
* Масштабируем графику без сохранения соотношения сторон, только при необходимости, например если оболочка графического элемента достигла границ `viewport`.

> Другими  словами `viewBox` растягивается или сжимается по необходимости заполнения `viewport` независимо от соотношения сторон. Графика может быть искажена.Значение `<meetOrSlice>`  будет проигнорировано.

#### `xMinYMin`
   
* Используем универсальное масштабирование
* Выравниваем `<min-x>` `viewBox` по наименьшему значению `X` `viewport`
* Выравниваем `<min-y>` `viewBox` по наименьшему значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 0% 0%;`

#### `xMinYMid`
   
* Используем универсальное масштабирование
* Выравниваем `<min-x>` `viewBox` по наименьшему значению `X` `viewport`
* Выравниваем `<mid-y>` `viewBox` по среднему значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 0% 50%;`

#### `xMinYMax`
   
* Используем универсальное масштабирование
* Выравниваем `<min-x>` `viewBox` по наименьшему значению `X` `viewport`
* Выравниваем `<min-y> + <height>` `viewBox` по максимальному значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 0% 100%;`

#### `xMidYMin`
   
* Используем универсальное масштабирование
* Выравниваем `<mid-x>` `viewBox` по среднему значению `X` `viewport`
* Выравниваем `<min-y>` `viewBox` по наименьшему значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 50% 0%;`

#### `xMidYMid` (значение по умолчанию)
   
* Используем универсальное масштабирование
* Выравниваем `<mid-x>` `viewBox` по среднему значению `X` `viewport`
* Выравниваем `<mid-y>` `viewBox` по среднему значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 50% 50%;`

#### `xMidYMax`
   
* Используем универсальное масштабирование
* Выравниваем `<mid-x>` `viewBox` по среднему значению `X` `viewport`
* Выравниваем `<min-y> + <height>` `viewBox` по максимальному значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 50% 100%;`

#### `xMaxYMin`
   
* Используем универсальное масштабирование
* Выравниваем `<min-x> + <width>` `viewBox` по максимальному значению `X` `viewport`
* Выравниваем `<min-y>` `viewBox` по наименьшему значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 100% 0%;`

#### `xMaxYMid`
   
* Используем универсальное масштабирование
* Выравниваем `<min-x> + <width>` `viewBox` по максимальному значению `X` `viewport`
* Выравниваем `<mid-y>` `viewBox` по среднему значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 100% 50%;`

#### `xMaxYMax`
   
* Используем универсальное масштабирование
* Выравниваем `<min-x> + <width>` `viewBox` по максимальному значению `X` `viewport`
* Выравниваем `<min-y> + <height>` `viewBox` по максимальному значению `Y` `viewport`

> Можете представлять это значение схожим с `background-position: 100% 100%;`


So, using the align and meetOrSlice values of the preserveAspectRatio attribute, you can specify whether or not to scale the viewBox uniformly, how to align it inside the viewport, and whether or not it should be entirely visible inside the viewport.

Sometimes, and depending on the size of the viewBox, some values may have similar results. For example, in the viewBox="0 0 200 300" example from earlier, some alignments are identical using different align values. The value of meetOrSlice is set to meet in this case so that the entire viewBox is contained inside the viewport.
The result of aligning the viewBox using different align values. The meetOrSlice value is set to meet.

If we were to change the meetOrSlice value to slice, we’d get different results for different values. Notice how the viewBox is stretched so that it covers the entire viewport. The x-axis is stretched so that the 200 units cover the viewport’s 800 units. In order for this to happen, and to maintain the aspect ratio of the viewbox, the y-axis gets “sliced off” at the bottom, but you can image it extending below the viewport’s height.
The result of aligning the viewBox using different align values. The meetOrSlice value is set to slice.

Of course, different viewBox values will also look different from the 200x300 we’re using here. For the sake of brevity, I won’t get into more examples, and I’ll leave you to play with an interactive demo I created to help you better visualize how the viewBox and different preserveAspectRatio values work together when different values are used. You can check the interactive demo out by visiting the link in the next section.

But before we move to that, I just want to note that the mid-x, mid-y, max-x, and max-y values change if the values of the <min-x> and <min-y> change. You can play with the interactive demo and change these values to see how the axes and thus the alignment of the viewBox changes accordingly.

The following image shows the effect of using viewBox = "100 0 200 300" on the position of the alignment axes. We’re using the same example as earlier, but instead of having the <min-x> value be set to zero, we’re setting it to 100. You can set them to any number value you want. Notice how the min-x, mid-x, and max-x axes change. The preserveAspectRatio used here is the default xMidYMid meet, which means that the mid-* axes are aligned with the middle axes of the viewport.
The effect of changing the value of <min-x> on the position of the x-axes. The translucent blue area shows the area which is considered to be the viewBox area after changing the value of <min-x>.
